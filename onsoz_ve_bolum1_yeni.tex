% ============================================================================
% YENİDEN YAZILMIŞ ÖNSÖZ VE BÖLÜM 1
% Kitabın genel akademik/öğretici üslubuna uygun hale getirilmiştir
% ============================================================================

\chapter*{Önsöz}
\addcontentsline{toc}{chapter}{Önsöz}

\textit{"Yazılım, düşüncenin somutlaşmış halidir."}

Yazılım mimarisinin evrimi, bilgisayar bilimlerinin en dinamik alanlarından birini oluşturur. 1970'lerden 2010'lara uzanan dönem, \textbf{Monolit Çağı} olarak adlandırılabilir. Bu dönemde tek büyük uygulamalar inşa edilmekte, sunucular fiziksel donanımlardan oluşmakta ve geliştirme döngüleri yıllar sürmekteydi. "Mimar" kavramı genellikle "en kıdemli geliştirici" anlamına gelmekte, mimari kararlar ise bir kez alındığında on yıl boyunca sorgulanmamaktaydı.

2010'larla birlikte başlayan \textbf{Dağıtık Çağı}, paradigmada köklü bir değişim getirdi. Mikroservisler, bulut platformları, DevOps kültürü ve konteynerler sahneye çıktı. Mimar, artık tek bir uygulamanın iç yapısını değil, onlarca servisin birbirleriyle nasıl iletişim kurduğunu tasarlamaktaydı. Netflix, Amazon ve Google'ın öncülük ettiği bu dönemde, "ölçeklenebilirlik" ve "esneklik" kavramları yazılım terminolojisinin merkezine yerleşti.

Günümüzde ise üçüncü bir çağın eşiğinde—ya da tam ortasında—bulunulmaktadır: \textbf{AI-Yerli Çağı}. Bu çağda yapay zeka, yazılımın sadece çıktısı değil, üretim sürecinin kendisi haline gelmektedir. Büyük dil modelleri kod üretmekte, otonom ajanlar API'leri orkestre etmekte, RAG sistemleri kurumsal bilgiyi yönetmektedir. Mimar artık sadece sistemleri değil, \textit{akıllı sistemleri} tasarlamakta; ve bu sistemler bazen kendi başlarına öğrenip karar alabilmektedir.

\section*{Kitabın Amacı ve Yaklaşımı}

Bu kitabın temel motivasyonu, mevcut literatürdeki bir boşluğu doldurmaktır. Piyasadaki mimari kitaplarının çoğu ya klasikleri tekrarlamakta—Gang of Four'un tasarım desenleri, Martin Fowler'ın enterprise pattern'leri—ya da sadece güncel teknolojileri anlatmaktadır. Oysa gerçek ihtiyaç, bu iki dünya arasında köprü kurmaktır: temel prensipleri atlamadan, onları modern bağlamda yorumlamak; bir Circuit Breaker pattern'inin hem geleneksel HTTP çağrıları hem de LLM API'leri için neden geçerli olduğunu göstermek; yapay zekayı "kitabın sonundaki ayrı bir bölüm" olarak değil, her konunun doğal bir parçası olarak ele almak.

Bu yaklaşım, kitabın her bölümüne yansımaktadır. Mikroservis tasarımı anlatılırken ajan entegrasyonu düşünülmekte, veri stratejisi belirlenirken RAG mimarisinin gereksinimleri hesaba katılmakta, dayanıklılık pattern'leri tartışılırken LLM API'lerinin olasılıksal doğası göz ardı edilmemektedir.

\section*{Hedef Kitle}

Bu kitap, deneyim seviyesi fark etmeksizin tüm yazılım profesyonellerine hitap etmektedir: kariyerinin başındaki junior geliştiriciler, yıllardır sektörde olan senior mühendisler ve teknik ekipleri yöneten liderler. Ortak payda, öğrenmeye açık olmak ve yazılımın geleceğini anlamak istemektir.

\section*{Kitabın Yapısı}

Kitap beş kısımdan oluşmakta ve her kısım bir öncekinin üzerine inşa edilmektedir:

\begin{enumerate}
    \item \textbf{Kısım I: Temeller ve Mimari Düşünce} — SOLID prensipleri, tasarım desenleri ve mimari düşünme biçimi. Hangi teknoloji kullanılırsa kullanılsın geçerliliğini koruyan evrensel doğrular.
    \item \textbf{Kısım II: Modern Mimari Desenleri ve Dağıtık Sistemler} — Mikroservisler, event-driven mimari, CQRS, saga pattern ve modern veri stratejileri.
    \item \textbf{Kısım III: Bulut Yerli ve Operasyonel Mükemmellik} — Docker, Kubernetes, serverless, observability ve FinOps.
    \item \textbf{Kısım IV: Yazılımın Evrimi ve Agentic Gelecek} — AI destekli geliştirme, agentic IDE'ler ve LLMOps.
    \item \textbf{Kısım V: Genel Yapay Zeka Çağında Mimari} — Otonom ajanlar, LangGraph, RAG pattern'leri, guardrails ve AGI vizyonu.
\end{enumerate}

Her bölüm bağımsız olarak okunabilir; ancak sıralı okuma, kavramların birbirine nasıl bağlandığını gösterecektir. Deneyimli mimarlar doğrudan dördüncü kısımdan başlayabilir; ancak temellerin tazelenmesi, modern kavramların daha derinden anlaşılmasını sağlayacaktır.

\begin{dikkat}
Bu kitaptaki yapay zeka bölümleri, Ocak 2026 itibarıyla günceldir. Ancak bu alan aylar—bazen haftalar—içinde değişmektedir. Bugün en iyi pratik kabul edilen, yarın eski kalabilir. Bu nedenle araçlara değil prensiplere odaklanılması, öğrenmenin sürdürülmesi ve teoride kalınmaması önerilmektedir.
\end{dikkat}

Yazılım mimarisi, teknolojik bir disiplin olmanın çok ötesinde bir düşünme biçimidir. Karmaşıklığı yönetmek, trade-off'ları değerlendirmek, belirsizlikle barışmak—bunlar sadece kod yazarak öğrenilmez. Yılların deneyimi, başarısızlıkların dersleri ve başkalarının hikayelerinden çıkarılan sonuçlar gerektirir.

\begin{center}
\textit{Yapay zeka çağında mimarlık,\\
insanlığın en yaratıcı mühendislik macerası olacak.}
\end{center}

\hfill Ocak 2026

%=============================================================================
\part{Temeller ve Mimari Düşünce}
%=============================================================================

\chapter{Yazılım Mimarisi Nedir?}

\textit{"Mimari, önemli olan her şeydir—her ne ise o."}

\hfill — Ralph Johnson

Her yazılım projesi bir yapıdır. En basit script bile belirli bir düzene sahiptir: bir giriş noktası, işlem mantığı ve sonuç. Ancak sistem büyüdükçe, bu yapının bilinçli olarak tasarlanması kaçınılmaz hale gelir. İşte bu bilinçli tasarım sürecine "yazılım mimarisi" denmektedir—ve bu kitabın tamamı, bu kavramı derinlemesine anlamaya adanmıştır.

\begin{ornekolay}
Küçük bir startup senaryosunu ele alalım: Birkaç bin satır kod, tek bir dosyada yaşayan veritabanı sorguları, iş mantığı ve kullanıcı arayüzü. Başlangıçta "mimari" kavramı düşünülmeden sadece özellik eklenmektedir. Ve bir süre bu yaklaşım işe yarar.

Ancak müşteri sayısı arttığında ve ekibe yeni geliştiriciler katıldığında sorunlar ortaya çıkar: Bir özelliği değiştirmek istendiğinde, başka on yerin bozulduğu fark edilir. Sistemin neden çöktüğünü anlamak için saatlerce kod okunur—çünkü hiç kimse "büyük resmi" bilmemektedir.

\textbf{Ders:} Mimari düşünce, küçük projelerde bile erken aşamalarda dikkate alınmalıdır.
\end{ornekolay}

\section{Mimarinin Tanımı ve Önemi}

Yazılım mimarisi için literatürde onlarca tanım bulunmaktadır. IEEE, SEI ve çeşitli akademisyenler farklı perspektifler sunmuştur. Bazıları teknik detaylara odaklanırken, bazıları organizasyonel boyutu vurgular. Pratikte en kullanışlı tanım şu şekilde ifade edilebilir:

\begin{ipucu}
\textbf{Yazılım Mimarisi:} Bir sistemin temel yapısıdır—bileşenleri, bu bileşenlerin birbirleriyle ve dış dünyayla ilişkileri, ve bu yapının zamanla nasıl evrileceğini belirleyen ilkeler.
\end{ipucu}

Bu tanım parçalara ayrıldığında, üç kritik unsurun ortaya çıktığı görülür:

\subsection{Bileşenler}

Bileşenler, sistemin yapı taşlarıdır. Bir bileşen; bir sınıf, bir modül, bir servis veya tam bir mikroservis olabilir. Önemli olan, her bileşenin net bir şekilde tanımlanmış sorumluluğa sahip olmasıdır. Tıpkı bir orkestradaki enstrümanlar gibi: keman keman işini yapar, davul davul işini yapar, ve birlikte uyum içinde çalarlar.

\subsection{Bileşenler Arası İlişkiler}

Hiçbir bileşen izole çalışmaz; hepsi birbirleriyle etkileşim halindedir. Bu etkileşimler çeşitli biçimlerde gerçekleşebilir:

\begin{itemize}
    \item \textbf{Senkron İletişim:} Bir bileşen diğerini doğrudan çağırır ve yanıt bekler—REST veya gRPC gibi protokollerle.
    \item \textbf{Asenkron Mesajlaşma:} Bir bileşen mesaj yayınlar ve başka bir bileşen bu mesajı alıp işler—Pub/Sub veya message queue sistemleriyle.
    \item \textbf{Paylaşımlı Veri:} Bileşenler ortak bir veri deposunu kullanır—ki bu genellikle dikkatli yönetilmesi gereken riskli bir tercihdir.
    \item \textbf{Olay Güdümlü:} Bir bileşen "şu oldu" diye bir olay yayınlar, ilgilenen kim varsa dinler ve tepki verir.
\end{itemize}

\subsection{Evrim İlkeleri}

Belki de en az takdir edilen unsur, evrim ilkeleridir. Hiçbir mimari sonsuza kadar sabit kalmaz. İş gereksinimleri değişir, teknolojiler eskir, ekipler büyür veya dağılır. İyi bir mimari, sadece bugünün ihtiyaçlarını karşılamaz; aynı zamanda yarının değişimlerine nasıl adapte olunacağının yol haritasını da çizer.

\begin{dikkat}
"Mimari" kelimesi duyulduğunda akla bir bina geliyorsa, bu metaforun sınırlarını anlamak gerekir. Bir binanın temelini inşaattan sonra değiştirmek mümkün değildir; ancak yazılım mimarisi evrimleşebilir—ve evrimleşmelidir.
\end{dikkat}

\section{Yazılım Mimarı Kimdir?}

Yazılım mimarı, teknik bir liderdir—ancak "liderlik" burada kod yazma becerisinin çok ötesinde anlamlar taşır. Mimarların ortak özellikleri incelendiğinde, birkaç kritik yetkinlik öne çıkmaktadır.

\subsection{Teknik Vizyon}

Mimar, sistemin teknik vizyonunu belirler ve korur. Bu, görünüşte basit ama aslında derin sorular sormayı gerektirir:

\begin{itemize}
    \item Sistem hangi kalite niteliklerine—performans, güvenlik, ölçeklenebilirlik—öncelik verecek?
    \item Hangi teknolojiler ve çerçeveler kullanılacak ve neden?
    \item Sistem nasıl parçalara ayrılacak—modüller mü, servisler mi, yoksa daha ince granüler yapılar mı?
    \item Takımlar arası teknik standartlar neler olacak ve bu standartlar nasıl uygulanacak?
\end{itemize}

Bu soruların hiçbirinin tek doğru cevabı yoktur; her biri bir dizi ödünleşim içerir. Ve mimar, bu ödünleşimleri bilinçli olarak yapar.

\subsection{Köprü Görevi}

Mimar aynı zamanda farklı dünyalar arasında köprü görevi görür. Ürün yöneticileri "hızlı teslim" isterken, güvenlik ekibi "kapsamlı denetim" talep eder. Finans departmanı "maliyet optimizasyonu" derken, operasyon ekibi "kararlılık" vurgular. Bu çelişen talepleri dengelemek, her birinin arkasındaki gerçek ihtiyacı anlamak ve ödünleşimleri şeffaf bir şekilde iletmek—işte bu, mimarın en zor ama en kritik görevidir.

\begin{ornekolay}
Bir e-ticaret platformu senaryosunu ele alalım. Ürün ekibi, "sepete ekle" işleminin anlık olmasını istemektedir—kullanıcı butona bastığında hiç beklememeli. Ancak envanter tutarlılığı için veritabanı kilitleri gerekmekte ve bu kilitler gecikmeye neden olmaktadır. İki tarafın istediği şey birbiriyle çelişmektedir.

\textbf{Çözüm:} "Eventual consistency" modeli önerilir: sepete ekleme işlemi anında onaylanır, ancak envanter kontrolü arka planda asenkron olarak yapılır. Stok bitmişse kullanıcı birkaç saniye sonra bilgilendirilir.

\textbf{Ödünleşim:} Anlık yanıt süresi karşılığında nadir durumlarda "stok bitti" bildirimi riski kabul edilmektedir.

İşte mimari budur—imkansız görünen talepleri yaratıcı ödünleşimlerle uzlaştırmak.
\end{ornekolay}

\subsection{Gelecek Odaklı Düşünme}

Mimar sadece bugünün değil yarının da mimarisini düşünür. Üç yıl sonra sistemin nasıl görüneceğini, hangi teknolojilerin eskiyeceğini, hangi yeni gereksinimlerin ortaya çıkacağını öngörmeye çalışır. Bu kehanet değildir; sistematik bir düşünme biçimidir. Trendleri takip eder, geçmiş deneyimlerden ders çıkarır ve her kararı "bu bizi geleceğe nasıl hazırlar?" sorusuyla test eder.

\section{Mimari Görünümler ve Dokümantasyon}

Bir mimariyi anlatmanın tek bir doğru yolu yoktur. Farklı paydaşlar, farklı perspektiflerden bakmak ister:

\begin{itemize}
    \item \textbf{Geliştirici:} Kod yapısını ve modül bağımlılıklarını görmek ister.
    \item \textbf{Operasyon ekibi:} Dağıtım topolojisini ve sunucu yapılandırmasını merak eder.
    \item \textbf{CEO:} Sadece sistemin iş hedeflerini nasıl desteklediğini anlamak ister.
\end{itemize}

Aynı mimariyi hepsine aynı diyagramla anlatmaya çalışmak, herkesin kafasını karıştırmaktan başka bir işe yaramaz.

\subsection{C4 Modeli}

Bu sorunu çözmek için çeşitli görselleştirme çerçeveleri geliştirilmiştir. Son yıllarda en pratik ve yaygın kabul göreni Simon Brown'ın \textbf{C4 Modeli} olmuştur. C4, dört seviyeden oluşan bir yaklaşım sunar:

\begin{enumerate}
    \item \textbf{Context (Bağlam):} Sistem kuşbakışı görülür: sistemin dış dünyayla ilişkisi, kullanıcıların kim olduğu ve hangi harici sistemlerle entegre olunduğu.
    \item \textbf{Container (Kapsayıcı):} Sistemin üst düzey yapısı: web uygulaması, API sunucusu, veritabanı, mesaj kuyruğu gibi büyük yapı taşları.
    \item \textbf{Component (Bileşen):} Bir kapsayıcının iç yapısı: API içindeki Controller, Service ve Repository bileşenleri gibi.
    \item \textbf{Code (Kod):} Bir bileşenin kod düzeyinde detayı—genellikle sadece kritik veya özellikle karmaşık bileşenler için çizilir.
\end{enumerate}

C4'ün gücü, "gerektiği kadar detay" ilkesinde yatar. Her şeyi tek bir diyagrama sığdırmaya çalışmak yerine, kim için çizildiği düşünülür ve o kişinin ihtiyaç duyduğu seviye seçilir.

\subsection{UML Kullanımı}

UML—1990'ların sonunda doğan bu modelleme dili—hâlâ kullanılmaktadır, ancak günümüzde genellikle tamamı değil, belirli diyagram türleri tercih edilmektedir:

\begin{itemize}
    \item \textbf{Sequence diyagramları:} Bileşenler arası etkileşimi göstermek için idealdir.
    \item \textbf{Class diyagramları:} Domain modelini anlatmak için kullanışlıdır.
    \item \textbf{State diyagramları:} Durum makineleri ve otonom ajanlar için kritiktir.
\end{itemize}

\begin{ipucu}
UML'i bir iletişim aracı olarak kullanın, bürokratik zorunluluk olarak değil. Hiç kimse elli sayfalık UML dokümanı okumaz. Birkaç anahtar diyagram, bin sayfa metinden daha değerlidir.
\end{ipucu}

\subsection{Dokümantasyon Dengesi}

Ne kadar dokümantasyon yeterlidir? Bu, yazılım dünyasının en eski tartışmalarından biridir:

\begin{itemize}
    \item \textbf{Yetersiz dokümantasyon:} Yeni katılan geliştiriciler kaybolur, bilgi tek tek kişilerin kafasında kalır ve o kişi ayrıldığında kaybolur.
    \item \textbf{Aşırı dokümantasyon:} Dokümanlar güncellenmedikçe gerçeklikten kopar ve kimse okumaz.
\end{itemize}

Altın kural "yaşayan dokümantasyon" oluşturmaktır: kod ile birlikte versiyonlanan, mümkünse otomatik olarak güncellenebilen ve gerçek soruları yanıtlayan dokümanlar.

\subsection{Architecture Decision Records (ADR)}

Yaşayan dokümantasyonun en etkili örneklerinden biri \textbf{ADR—Architecture Decision Record}—formatıdır. Her kritik mimari karar, tarihçesiyle birlikte kaydedilir:

\begin{itemize}
    \item Ne karar alındı?
    \item Neden alındı?
    \item Hangi alternatifler değerlendirildi?
    \item Sonuçları neler oldu?
\end{itemize}

Altı ay sonra "bu veritabanını neden seçmiştik?" sorusu sorulduğunda, cevap orada yazılıdır. Bu konu Bölüm 10'da detaylı incelenecektir.

\section*{Bölüm Özeti}

Bu bölümde yazılım mimarisinin temel kavramları, mimarın rolü ve dokümantasyon yaklaşımları incelendi. Ancak "iyi mimari" denildiğinde aslında ne kastedildiği henüz tanımlanmadı. Bir sonraki bölümde, mimarinin gerçek değerini belirleyen kavramlara geçilecektir: performans, güvenlik, ölçeklenebilirlik ve daha fazlası. Yazılım dünyasının meşhur "-ility" sonekli kalite niteliklerine dalınacaktır.
